// Shared element renderer for runtime (display, participant, control pages)
// Based on editor element renderer but without editing capabilities

var RuntimeRenderer = RuntimeRenderer || {};

RuntimeRenderer.ElementRenderer = (function() {
    /**
     * Render an element on a canvas (display/control/participant view)
     * @param {HTMLElement} container - The container to render into
     * @param {Object} element - The element data
     * @param {Object} options - Rendering options (insideContainer, runtime mode)
     */
    function renderElement(container, element, options = {}) {
        const insideContainer = options.insideContainer || false;
        const mode = options.mode || 'display'; // 'display', 'participant', 'control'
        
        const el = document.createElement('div');
        el.className = 'runtime-element';
        el.id = `element-${element.id}`;
        
        // Positioning
        if (!insideContainer) {
            el.style.position = 'absolute';
            el.style.left = `${element.x}px`;
            el.style.top = `${element.y}px`;
            el.style.width = `${element.width}px`;
            el.style.height = `${element.height}px`;
        } else {
            el.style.position = 'relative';
            el.style.width = '100%';
            el.style.height = 'auto';
        }
        
        // Render based on element type (check both type and media_type for media elements)
        const elementType = element.type || element.media_type;
        
        switch (elementType) {
            case 'image':
                renderImage(el, element);
                break;
            case 'video':
                renderVideo(el, element);
                break;
            case 'audio':
                renderAudio(el, element);
                break;
            case 'rectangle':
                renderRectangle(el, element);
                break;
            case 'circle':
                renderCircle(el, element);
                break;
            case 'triangle':
                renderTriangle(el, element);
                break;
            case 'arrow':
                renderArrow(el, element);
                break;
            case 'line':
                renderLine(el, element);
                break;
            case 'text':
                renderText(el, element);
                break;
            case 'richtext':
                renderRichText(el, element);
                break;
            case 'audio_control':
                if (mode === 'control') {
                    renderAudioControl(el, element, options);
                }
                break;
            case 'answer_input':
                if (mode === 'participant') {
                    renderAnswerInput(el, element, options);
                }
                break;
            case 'answer_display':
                if (mode === 'control') {
                    renderAnswerDisplay(el, element, options);
                }
                break;
            case 'appearance_control':
                if (mode === 'control') {
                    renderAppearanceControl(el, element, options);
                }
                break;
            default:
                console.warn('Unknown element type:', element.type, element);
                break;
        }
        
        // Apply rotation
        const finalElementType = element.type || element.media_type;
        if (finalElementType !== 'line' && element.rotation) {
            el.style.transform = `rotate(${element.rotation}deg)`;
            el.style.transformOrigin = 'center center';
        }
        
        // Apply visibility - but don't override if it's undefined (default to visible)
        // Only hide if explicitly set to false
        if (element.visible === false) {
            el.style.display = 'none';
        }
        
        if (!insideContainer) {
            container.appendChild(el);
        }
        
        return el;
    }
    
    function renderImage(el, element) {
        const img = document.createElement('img');
        // Try multiple ways to get the image source (new format uses media_url, old format uses src)
        let imageSrc = element.media_url || 
                      element.src || 
                      (element.file_name ? '/api/media/serve/' + element.file_name : '') ||
                      (element.filename ? '/api/media/serve/' + element.filename : '') ||
                      (element.image_src || '');
        
        if (!imageSrc) {
            console.warn('Image element has no source:', element);
            el.textContent = 'Image (no source)';
            el.style.display = 'flex';
            el.style.alignItems = 'center';
            el.style.justifyContent = 'center';
            el.style.color = '#999';
            el.style.border = '2px dashed #ccc';
            return;
        }
        
        img.src = imageSrc;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'contain';
        img.onerror = () => {
            console.error('Failed to load image:', imageSrc, element);
            el.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #999; border: 2px dashed #ccc;">Image failed to load</div>';
        };
        el.appendChild(img);
        el.style.border = 'none';
    }
    
    function renderVideo(el, element) {
        const video = document.createElement('video');
        // New format uses media_url, old format uses src
        video.src = element.media_url || element.src || (element.file_name ? '/api/media/serve/' + element.file_name : '') || (element.filename ? '/api/media/serve/' + element.filename : '');
        video.controls = false; // Control via quizmaster only
        video.style.width = '100%';
        video.style.height = '100%';
        video.style.objectFit = 'contain';
        video.id = `video-${element.id}`;
        el.appendChild(video);
        el.style.border = 'none';
    }
    
    function renderAudio(el, element) {
        const audioIcon = document.createElement('div');
        audioIcon.innerHTML = 'ðŸ”Š';
        audioIcon.style.cssText = 'display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; font-size: 64px;';
        el.appendChild(audioIcon);
        
        const audioElement = document.createElement('audio');
        // New format uses media_url, old format uses src
        audioElement.src = element.media_url || element.src || (element.file_name ? '/api/media/serve/' + element.file_name : '') || (element.filename ? '/api/media/serve/' + element.filename : '');
        audioElement.style.display = 'none';
        audioElement.id = `audio-${element.id}`;
        el.appendChild(audioElement);
        el.style.border = 'none';
    }
    
    function renderRectangle(el, element) {
        el.style.backgroundColor = element.fill_color || '#ddd';
        el.style.border = `${element.border_width || 2}px solid ${element.border_color || '#999'}`;
    }
    
    function renderCircle(el, element) {
        el.style.borderRadius = '50%';
        el.style.backgroundColor = element.fill_color || '#ddd';
        el.style.border = `${element.border_width || 2}px solid ${element.border_color || '#999'}`;
    }
    
    function renderTriangle(el, element) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', `0 0 ${element.width} ${element.height}`);
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        path.setAttribute('points', `${element.width/2},0 ${element.width},${element.height} 0,${element.height}`);
        path.setAttribute('fill', element.fill_color || '#ddd');
        path.setAttribute('stroke', element.border_color || '#999');
        path.setAttribute('stroke-width', element.border_width || 2);
        svg.appendChild(path);
        el.appendChild(svg);
        el.style.border = 'none';
    }
    
    function renderArrow(el, element) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', `0 0 ${element.width} ${element.height}`);
        
        const arrowHeadLength = element.arrow_head_length || Math.min(element.width, element.height) * 0.3;
        const arrowBodyThickness = element.arrow_body_thickness || Math.min(element.width, element.height) * 0.2;
        const arrowBodyWidth = element.width - arrowHeadLength;
        const bodyTop = (element.height - arrowBodyThickness) / 2;
        const bodyBottom = bodyTop + arrowBodyThickness;
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', `M 0 ${bodyTop} L ${arrowBodyWidth} ${bodyTop} L ${arrowBodyWidth} 0 L ${element.width} ${element.height/2} L ${arrowBodyWidth} ${element.height} L ${arrowBodyWidth} ${bodyBottom} L 0 ${bodyBottom} Z`);
        path.setAttribute('fill', element.fill_color || '#ddd');
        path.setAttribute('stroke', element.border_color || '#999');
        path.setAttribute('stroke-width', element.border_width || 2);
        svg.appendChild(path);
        el.appendChild(svg);
        el.style.border = 'none';
    }
    
    function renderLine(el, element) {
        el.style.width = `${Math.max(element.width, element.height)}px`;
        el.style.height = `${element.border_width || 2}px`;
        el.style.backgroundColor = element.fill_color || element.border_color || '#999';
        el.style.border = 'none';
        el.style.transformOrigin = '0 0';
        if (element.rotation) {
            el.style.transform = `rotate(${element.rotation}deg)`;
        }
    }
    
    function renderText(el, element) {
        // Text elements can have html or text property
        if (element.html) {
            el.innerHTML = element.html;
        } else if (element.text) {
            el.textContent = element.text;
        }
        el.style.fontSize = `${element.font_size || 24}px`;
        el.style.color = element.color || element.text_color || '#fff';
        el.style.backgroundColor = element.background_color || 'transparent';
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = 'center';
        el.style.padding = '0.5rem';
        el.style.wordWrap = 'break-word';
        el.style.overflow = 'hidden';
        el.style.border = 'none';
        el.style.textAlign = element.text_align || 'center';
    }
    
    function renderRichText(el, element) {
        el.innerHTML = element.content || '';
        el.style.fontSize = `${element.font_size || 16}px`;
        el.style.color = element.text_color || '#000000';
        el.style.backgroundColor = element.background_color || 'transparent';
        el.style.padding = '8px';
        el.style.overflow = 'auto';
        el.style.wordWrap = 'break-word';
        el.style.border = 'none';
        el.style.textAlign = 'left';
    }
    
    function renderAudioControl(el, element, options) {
        el.style.backgroundColor = '#f5f5f5';
        el.style.border = '1px solid #ddd';
        el.style.borderRadius = '4px';
        el.style.padding = '0.5rem';
        el.style.display = 'flex';
        el.style.flexDirection = 'column';
        el.style.gap = '0.5rem';
        
        const filenameLabel = document.createElement('div');
        // New format uses file_name, old format uses filename
        let filename = element.file_name || element.filename || (element.media_type === 'video' ? 'Video' : 'Audio');
        if (filename && typeof filename === 'string') {
            filename = filename.split('/').pop().split('\\').pop();
        }
        filenameLabel.textContent = filename || (element.media_type === 'video' ? 'Video' : 'Audio');
        filenameLabel.style.fontWeight = '500';
        filenameLabel.style.fontSize = '0.9rem';
        filenameLabel.style.color = '#333';
        el.appendChild(filenameLabel);
        
        const controlsContainer = document.createElement('div');
        controlsContainer.style.display = 'flex';
        controlsContainer.style.gap = '0.5rem';
        controlsContainer.style.alignItems = 'center';
        
        const playBtn = document.createElement('button');
        playBtn.textContent = 'â–¶ Play';
        playBtn.className = 'control-play-btn';
        playBtn.dataset.elementId = element.parent_id || element.id;
        playBtn.style.cssText = 'padding: 0.5rem 1rem; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;';
        controlsContainer.appendChild(playBtn);
        
        const pauseBtn = document.createElement('button');
        pauseBtn.textContent = 'â¸ Pause';
        pauseBtn.className = 'control-pause-btn';
        pauseBtn.dataset.elementId = element.parent_id || element.id;
        pauseBtn.style.cssText = 'padding: 0.5rem 1rem; background: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;';
        controlsContainer.appendChild(pauseBtn);
        
        el.appendChild(controlsContainer);
        
        // Hidden media element for playback
        // New format uses media_url, old format uses src
        const mediaSrc = element.media_url || element.src || (element.file_name ? '/api/media/serve/' + element.file_name : '') || (element.filename ? '/api/media/serve/' + element.filename : '');
        
        if (element.media_type === 'video') {
            const video = document.createElement('video');
            video.style.display = 'none';
            video.src = mediaSrc;
            video.id = `video-control-${element.id}`;
            el.appendChild(video);
        } else {
            const audio = document.createElement('audio');
            audio.style.display = 'none';
            audio.src = mediaSrc;
            audio.id = `audio-control-${element.id}`;
            el.appendChild(audio);
        }
    }
    
    function renderAnswerInput(el, element, options) {
        // Renders answer input elements for participant view
        // Uses question-type definitions from question-types folder
        // All answer input rendering should go through these modular renderers
        
        // Get question_type from question_config or fallback to old answer_type
        const answerType = (element.question_config && element.question_config.question_type) || element.answer_type || 'text';
        const questionId = element.parent_id;
        const question = options.question || null; // Get question element from options for image_click
        const submittedAnswer = options.submittedAnswer || null;
        
        // Create white container for answer elements with border matching control view
        const container = document.createElement('div');
        container.style.cssText = 'background-color: white; padding: 1rem; border: 2px solid #2196F3; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); width: 100%; height: 100%; box-sizing: border-box; display: flex; flex-direction: column;';
        el.appendChild(container);
        
        // Get question title from question element (new format: in question_config)
        const questionTitle = question && question.question_config ? (question.question_config.question_title || '') : '';
        
        // Use new modular question type participant views from question-types folder
        const renderOptions = Object.assign({}, options, { question: question, questionTitle: questionTitle });
        
        // Route to appropriate question type participant view renderer (from question-types folder)
        if (answerType === 'text' && QuestionTypes.Text && QuestionTypes.Text.ParticipantView) {
            QuestionTypes.Text.ParticipantView.render(container, element, renderOptions);
        } else if (answerType === 'radio' && QuestionTypes.Radio && QuestionTypes.Radio.ParticipantView) {
            QuestionTypes.Radio.ParticipantView.render(container, element, renderOptions);
        } else if (answerType === 'checkbox' && QuestionTypes.Checkbox && QuestionTypes.Checkbox.ParticipantView) {
            QuestionTypes.Checkbox.ParticipantView.render(container, element, renderOptions);
        } else if (answerType === 'image_click' && QuestionTypes.ImageClick && QuestionTypes.ImageClick.ParticipantView) {
            QuestionTypes.ImageClick.ParticipantView.render(container, element, renderOptions);
        } else if (answerType === 'stopwatch' && QuestionTypes.Stopwatch && QuestionTypes.Stopwatch.ParticipantView) {
            QuestionTypes.Stopwatch.ParticipantView.render(container, element, renderOptions);
        } else {
            // Unknown question type - show error message
            console.error('Question type', answerType, 'participant view not found');
            container.textContent = `Answer input type "${answerType}" not supported`;
            container.style.cssText = 'padding: 1rem; color: red; border: 2px solid red;';
        }
    }
    
    function renderAnswerDisplay(el, element, options) {
        // Renders answer display elements for control view
        // Uses question-type definitions from question-types folder
        // All answer display rendering should go through these modular renderers
        
        // Get question_type from question_config or fallback to old answer_type
        // options.answerType is determined with fallback: answer_display -> answer_input -> question
        const answerType = options.answerType || (element.question_config && element.question_config.question_type) || element.answer_type || 'text';
        
        // Create white container for answer elements
        const container = document.createElement('div');
        container.style.cssText = 'background-color: white; padding: 1rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); width: 100%; height: 100%; box-sizing: border-box;';
        
        // For image_click questions, enable scrolling while maintaining fixed size
        if (answerType === 'image_click') {
            container.style.overflowY = 'auto';
            container.style.overflowX = 'hidden';
            // Keep the fixed height from element.height (set earlier in renderElement)
        }
        
        el.appendChild(container);
        
        const questionId = element.parent_id;
        const questionTitle = options.questionTitle || 'Question';
        const answers = options.answers || {}; // { participant_id: { answer, submission_time, correct, bonus_points } }
        const participants = options.participants || {}; // { participant_id: { name, avatar } }
        const onMarkAnswer = options.onMarkAnswer || null;
        const imageSrc = options.imageSrc || '';
        
        // Use new modular question type renderers from question-types folder
        const renderOptions = {
            questionId: questionId,
            questionTitle: questionTitle,
            answers: answers,
            participants: participants,
            onMarkAnswer: onMarkAnswer,
            imageSrc: imageSrc,
            answerType: answerType,
            question: options.question || null // Pass question element to access correct_answer
        };
        
        // Route to appropriate question type control view renderer (from question-types folder)
        if (answerType === 'image_click' && QuestionTypes.ImageClick && QuestionTypes.ImageClick.ControlView) {
            QuestionTypes.ImageClick.ControlView.render(container, renderOptions);
        } else if (answerType === 'text' && QuestionTypes.Text && QuestionTypes.Text.ControlView) {
            QuestionTypes.Text.ControlView.render(container, renderOptions);
        } else if (answerType === 'radio' && QuestionTypes.Radio && QuestionTypes.Radio.ControlView) {
            QuestionTypes.Radio.ControlView.render(container, renderOptions);
        } else if (answerType === 'checkbox' && QuestionTypes.Checkbox && QuestionTypes.Checkbox.ControlView) {
            QuestionTypes.Checkbox.ControlView.render(container, renderOptions);
        } else if (answerType === 'stopwatch' && QuestionTypes.Stopwatch && QuestionTypes.Stopwatch.ControlView) {
            QuestionTypes.Stopwatch.ControlView.render(container, renderOptions);
        } else {
            // Unknown question type - show error message
            console.error('Question type', answerType, 'control view not found');
            container.textContent = `Answer display type "${answerType}" not supported`;
            container.style.cssText = 'padding: 1rem; color: red; border: 2px solid red;';
        }
    }
    
    function renderAppearanceControl(el, element, options) {
        // Use the dedicated appearance control renderer (shared with editor)
        if (Editor && Editor.AppearanceControlRenderer && Editor.AppearanceControlRenderer.render) {
            Editor.AppearanceControlRenderer.render(el, element, {
                getCurrentQuiz: () => options.quiz || null,
                getCurrentPageIndex: () => {
                    // Try to get page index from quiz
                    if (options.quiz && options.page) {
                        const index = options.quiz.pages.findIndex(p => p === options.page);
                        return index >= 0 ? index : 0;
                    }
                    return 0;
                },
                getCurrentView: () => 'control',
                isRuntime: true, // Runtime mode - toggles are functional
                socket: options.socket || null,
                roomCode: options.roomCode || null
            });
        } else {
            // Fallback if renderer not available
            el.innerHTML = '<p style="padding: 1rem; color: #666;">Appearance control renderer not available</p>';
        }
    }
    
    return {
        renderElement: renderElement
    };
})();
